list的基本实现技术
Python标准类型list就是一种元素个数可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序），而且还具有以下行为特征：

基于下标（位置）的高效元素访问和更新，时间复杂度应该是O(1)；

为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。

允许任意加入元素，而且在不断加入元素的过程中，表对象的标识（函数id得到的值）不变。

为满足该特征，就必须能更换元素存储区，并且为保证更换存储区时list对象的标识id不变，只能采用分离式实现技术。

在Python的官方实现中，list就是一种采用分离式技术实现的动态顺序表。这就是为什么用list.append(x) （或 list.insert(len(list), x)，即尾部插入）比在指定位置插入元素效率高的原因。

在Python的官方实现中，list实现采用了如下的策略：在建立空表（或者很小的表）时，系统分配一块能容纳8个元素的存储区；在执行插入操作（insert或append）时，如果元素存储区满就换一块4倍大的存储区。但如果此时的表已经很大（目前的阀值为50000），则改变策略，采用加一倍的方法。引入这种改变策略的方式，是为了避免出现过多空闲的存储位置。

冒泡排序
def bubble_sort(alist):
    for j in range(len(alist)-1,0,-1):
        # j表示每次遍历需要比较的次数，是逐渐减小的
        for i in range(j):
            if alist[i] > alist[i+1]:
                alist[i], alist[i+1] = alist[i+1], alist[i]

 快速排序

def quick_sort(b):
    """快速排序"""
    if len(b) < 2:
        return arr
    # 选取基准，随便选哪个都可以，选中间的便于理解
    mid = arr[len(b) // 2]
    # 定义基准值左右两个数列
    left, right = [], []
    # 从原始数组中移除基准值
    b.remove(mid)
    for item in b:
        # 大于基准值放右边
        if item >= mid:
            right.append(item)
        else:
            # 小于基准值放左边
            left.append(item)
    # 使用迭代进行比较
    return quick_sort(left) + [mid] + quick_sort(right)

  mysql的4种隔离级别：
  1. 读未提交（read-uncommitted） -- 脏读： 事务A读取到了事务B更新的数据，然后B回滚操作，那么A读到的就是脏数据；
  2. 不可重复读 （read-committed） -- 事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据做了更新并提交，导致事务A多次读取同一数据时，结果不一致；
  3. 幻读 （repeatable-read）-- 不可重复读侧重于修改，幻读侧重于新增和删除，解决不可重复读 的问题只需要锁住行满足条件的行，解决幻读需要锁表；
  4. 串行化 （serializable）

  事务的基本要素：
  A： 原子性 -- 事务开始后的所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节；
  C： 一致性 -- 事务开始前和结束后，数据库的完整性约束并没有被破坏，比如A向B转账，不可能A扣了钱，B却没收到；
  I： 隔离性 -- 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰；
  D： 持久性 -- 事务完成后，事务对数据库的所有更新将保存到数据库，不能回滚。